<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animation Preview</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #2c3e50;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
        }
        .preview-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            padding: 10px;
            max-width: 100%;
        }
        #p5-canvas {
            position: relative;
            display: inline-block;
        }
        #p5-canvas canvas {
            display: block;
            border-radius: 4px;
        }
        .loading-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(44, 62, 80, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            border-radius: 4px;
        }
        .loading-spinner {
            width: 40px; height: 40px;
            border: 3px solid rgba(108, 92, 231, 0.3);
            border-top: 3px solid #6c5ce7;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .loading-text {
            color: #e0e0e0;
            font-size: 14px;
            margin-top: 12px;
        }
        .loading-progress {
            color: #a0a0a0;
            font-size: 12px;
            margin-top: 4px;
            font-family: 'Courier New', monospace;
        }
        .controls {
            background: rgba(30, 30, 50, 0.9);
            padding: 8px 14px;
            border-radius: 6px;
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }
        .ctrl-btn {
            background: #6c5ce7;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
        }
        .ctrl-btn:hover { background: #5f4dd1; }
        .ctrl-btn.secondary { background: #34495e; }
        .ctrl-btn.secondary:hover { background: #2c3e50; }
        .progress-bar {
            flex: 1;
            height: 5px;
            background: rgba(0,0,0,0.3);
            border-radius: 3px;
            position: relative;
            cursor: pointer;
            min-width: 120px;
        }
        .progress-fill {
            position: absolute;
            top: 0; left: 0;
            height: 100%;
            background: #27ae60;
            border-radius: 3px;
            transition: width 0.1s;
        }
        .time-display {
            color: #e0e0e0;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            min-width: 60px;
            text-align: center;
        }
        .waiting {
            color: #888;
            text-align: center;
            padding: 40px;
            font-size: 14px;
        }
        .no-data {
            color: #e0e0e0;
            text-align: center;
            padding: 40px;
        }
    </style>
</head>
<body>
    <div id="waiting-msg" class="waiting">Waiting for animation data...</div>
    <div class="preview-container" id="preview-container" style="display:none;">
        <div id="p5-canvas">
            <div class="loading-overlay" id="loading-overlay">
                <div class="loading-spinner"></div>
                <div class="loading-text">Loading Animation...</div>
                <div class="loading-progress" id="loading-progress">0 / 0 layers</div>
            </div>
        </div>
        <div class="controls">
            <button class="ctrl-btn" id="play-btn" onclick="togglePlay()">&#9654;&#65039;</button>
            <button class="ctrl-btn secondary" onclick="stopAnimation()">&#9209;&#65039;</button>
            <label style="display:flex;align-items:center;gap:4px;color:#e0e0e0;font-size:12px;cursor:pointer;">
                <input type="checkbox" id="loop-checkbox" checked style="cursor:pointer;"> Loop
            </label>
            <div class="progress-bar" id="progress-bar" onclick="seek(event)">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
            <div class="time-display" id="time-display">0.00s</div>
        </div>
    </div>

    <script>
        var animationData = null;
        var currentTime = 0;
        var isPlaying = false;
        var CANVAS_WIDTH = 800;
        var CANVAS_HEIGHT = 600;

        // Listen for animation data from parent
        window.addEventListener('message', function(e) {
            var msg = e.data;
            if (!msg || msg.type !== 'LOAD_PREVIEW') return;

            animationData = msg.data;
            if (!animationData || !animationData.layers) {
                document.getElementById('waiting-msg').innerHTML = '<div class="no-data"><h3>No Animation Data</h3><p>Unable to load animation preview</p></div>';
                return;
            }

            // Backward compat
            if (animationData.smoothPlayback === undefined) animationData.smoothPlayback = false;
            if (!animationData.backgroundKeyframes) {
                animationData.backgroundKeyframes = [
                    { time: 0, color: (animationData.settings && animationData.settings.backgroundColor) || '#2c3e50' }
                ];
            }

            // Check loop preference from saved data
            var loopCb = document.getElementById('loop-checkbox');
            if (loopCb && animationData.loopEnabled !== undefined) {
                loopCb.checked = animationData.loopEnabled;
            }

            document.getElementById('waiting-msg').style.display = 'none';
            document.getElementById('preview-container').style.display = 'flex';

            // p5.js will call setup() automatically once we create the sketch
            // We need to start p5 here since data is loaded async
            new p5(function(p) {
                var loadedCount = 0;
                var totalLayers = animationData.layers.length;

                p.setup = function() {
                    var canvas = p.createCanvas(CANVAS_WIDTH, CANVAS_HEIGHT);
                    canvas.parent('p5-canvas');
                    p.frameRate((animationData.settings && animationData.settings.fps) || 30);
                    p.imageMode(p.CENTER);
                    p.angleMode(p.DEGREES);

                    var loadingProgress = document.getElementById('loading-progress');
                    var loadingOverlay = document.getElementById('loading-overlay');

                    if (loadingProgress) loadingProgress.textContent = '0 / ' + totalLayers + ' layers';

                    function checkAllLoaded() {
                        loadedCount++;
                        if (loadingProgress) loadingProgress.textContent = loadedCount + ' / ' + totalLayers + ' layers';

                        if (loadedCount >= totalLayers) {
                            if (loadingOverlay) {
                                loadingOverlay.style.transition = 'opacity 0.3s';
                                loadingOverlay.style.opacity = '0';
                                setTimeout(function() { loadingOverlay.style.display = 'none'; }, 300);
                            }
                            setTimeout(function() { togglePlay(); }, 500);
                            window.parent.postMessage({ type: 'PREVIEW_LOADED' }, window.location.origin);
                        }
                    }

                    if (totalLayers === 0) {
                        if (loadingOverlay) loadingOverlay.style.display = 'none';
                        window.parent.postMessage({ type: 'PREVIEW_LOADED' }, window.location.origin);
                        return;
                    }

                    animationData.layers.forEach(function(layer) {
                        p.loadImage(layer.imageUrl, function(img) {
                            layer.image = img;
                            checkAllLoaded();
                        }, function() {
                            console.error('Failed to load image for layer:', layer.name);
                            checkAllLoaded();
                        });
                    });

                    // 30s timeout safety
                    setTimeout(function() {
                        if (loadedCount < totalLayers) {
                            if (loadingOverlay && loadingOverlay.style.display !== 'none') {
                                loadingOverlay.style.transition = 'opacity 0.3s';
                                loadingOverlay.style.opacity = '0';
                                setTimeout(function() { loadingOverlay.style.display = 'none'; }, 300);
                                setTimeout(function() { togglePlay(); }, 500);
                            }
                        }
                    }, 30000);
                };

                p.draw = function() {
                    var bgColor = getBackgroundColor(currentTime);
                    p.background(bgColor);

                    if (isPlaying) {
                        currentTime += p.deltaTime;
                        var endTime = getAnimationEndTime();
                        var loopCb = document.getElementById('loop-checkbox');
                        var loopOn = loopCb ? loopCb.checked : true;

                        if (currentTime > endTime) {
                            if (loopOn) {
                                currentTime = 0;
                            } else {
                                currentTime = endTime;
                                stopAnimation();
                            }
                        }
                        updateTimeDisplay();
                        updateProgress();
                    }

                    animationData.layers.forEach(function(layer) {
                        if (!layer.visible || !layer.image) return;
                        var props = interpolateProperties(currentTime, layer);
                        if (props && props.visible !== false) {
                            p.push();
                            p.translate(props.x, props.y);
                            p.rotate(props.rotation);
                            p.scale(props.scaleX, props.scaleY);
                            p.tint(255, layer.opacity || 255);
                            p.image(layer.image, 0, 0);
                            p.pop();
                        }
                    });
                };
            });
        });

        // Signal to parent that we're ready
        window.parent.postMessage({ type: 'PREVIEW_READY' }, window.location.origin);

        function getAnimationEndTime() {
            var maxTime = 0;
            animationData.layers.forEach(function(layer) {
                layer.keyframes.forEach(function(kf) {
                    if (kf.time > maxTime) maxTime = kf.time;
                });
            });
            return maxTime;
        }

        function interpolateProperties(time, layer) {
            if (!layer || layer.keyframes.length === 0) return null;
            if (layer.keyframes.length === 1) return Object.assign({}, layer.keyframes[0]);

            var smoothOn = animationData.smoothPlayback || false;
            if (!smoothOn) {
                var threshold = 100;
                for (var i = 0; i < layer.keyframes.length; i++) {
                    if (Math.abs(layer.keyframes[i].time - time) < threshold) {
                        return Object.assign({}, layer.keyframes[i]);
                    }
                }
            }

            var prevKf = layer.keyframes[0];
            var nextKf = layer.keyframes[layer.keyframes.length - 1];
            for (var i = 0; i < layer.keyframes.length - 1; i++) {
                if (layer.keyframes[i].time <= time && layer.keyframes[i + 1].time >= time) {
                    prevKf = layer.keyframes[i];
                    nextKf = layer.keyframes[i + 1];
                    break;
                }
            }

            if (time < prevKf.time) return Object.assign({}, prevKf);
            if (time > nextKf.time) return Object.assign({}, nextKf);

            var progress = (time - prevKf.time) / (nextKf.time - prevKf.time);
            var eased = applyEasing(progress, prevKf.easing || 'linear');

            return {
                x: lerp(prevKf.x, nextKf.x, eased),
                y: lerp(prevKf.y, nextKf.y, eased),
                scaleX: lerp(prevKf.scaleX, nextKf.scaleX, eased),
                scaleY: lerp(prevKf.scaleY, nextKf.scaleY, eased),
                rotation: lerp(prevKf.rotation, nextKf.rotation, eased),
                visible: prevKf.visible !== false
            };
        }

        function lerp(a, b, t) { return a + (b - a) * t; }

        function getBackgroundColor(time) {
            if (!animationData.backgroundKeyframes || animationData.backgroundKeyframes.length === 0) {
                return (animationData.settings && animationData.settings.backgroundColor) || '#2c3e50';
            }
            if (animationData.backgroundKeyframes.length === 1) return animationData.backgroundKeyframes[0].color;

            var prevKf = animationData.backgroundKeyframes[0];
            var nextKf = animationData.backgroundKeyframes[animationData.backgroundKeyframes.length - 1];
            for (var i = 0; i < animationData.backgroundKeyframes.length - 1; i++) {
                if (animationData.backgroundKeyframes[i].time <= time && animationData.backgroundKeyframes[i + 1].time >= time) {
                    prevKf = animationData.backgroundKeyframes[i];
                    nextKf = animationData.backgroundKeyframes[i + 1];
                    break;
                }
            }

            if (time < prevKf.time) return prevKf.color;
            if (time > nextKf.time) return nextKf.color;

            var progress = (time - prevKf.time) / (nextKf.time - prevKf.time);
            return interpolateColor(prevKf.color, nextKf.color, progress);
        }

        function interpolateColor(c1, c2, t) {
            var hexToRgb = function(hex) {
                var r = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return r ? { r: parseInt(r[1], 16), g: parseInt(r[2], 16), b: parseInt(r[3], 16) } : { r: 44, g: 62, b: 80 };
            };
            var a = hexToRgb(c1), b = hexToRgb(c2);
            var rr = Math.round(a.r + (b.r - a.r) * t);
            var gg = Math.round(a.g + (b.g - a.g) * t);
            var bb = Math.round(a.b + (b.b - a.b) * t);
            return '#' + [rr, gg, bb].map(function(x) { return x.toString(16).padStart(2, '0'); }).join('');
        }

        function applyEasing(t, type) {
            switch (type) {
                case 'linear': return t;
                case 'easeInQuad': return t * t;
                case 'easeOutQuad': return t * (2 - t);
                case 'easeInOutQuad': return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
                case 'easeInCubic': return t * t * t;
                case 'easeOutCubic': return (--t) * t * t + 1;
                case 'easeInOutCubic': return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
                case 'easeInQuart': return t * t * t * t;
                case 'easeOutQuart': return 1 - (--t) * t * t * t;
                case 'easeInOutQuart': return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t;
                case 'easeInBack': var c1 = 1.70158; return (c1 + 1) * t * t * t - c1 * t * t;
                case 'easeOutBack': var c2 = 1.70158; return 1 + (c2 + 1) * Math.pow(t - 1, 3) + c2 * Math.pow(t - 1, 2);
                case 'easeInOutBack': var c3 = 1.70158 * 1.525; return t < 0.5 ? (Math.pow(2 * t, 2) * ((c3 + 1) * 2 * t - c3)) / 2 : (Math.pow(2 * t - 2, 2) * ((c3 + 1) * (t * 2 - 2) + c3) + 2) / 2;
                case 'easeInElastic': var c4 = (2 * Math.PI) / 3; return t === 0 ? 0 : t === 1 ? 1 : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * c4);
                case 'easeOutElastic': var c5 = (2 * Math.PI) / 3; return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c5) + 1;
                case 'easeInOutElastic': var c6 = (2 * Math.PI) / 4.5; return t === 0 ? 0 : t === 1 ? 1 : t < 0.5 ? -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * c6)) / 2 : (Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * c6)) / 2 + 1;
                case 'easeOutBounce':
                    var n1 = 7.5625, d1 = 2.75;
                    if (t < 1 / d1) return n1 * t * t;
                    else if (t < 2 / d1) return n1 * (t -= 1.5 / d1) * t + 0.75;
                    else if (t < 2.5 / d1) return n1 * (t -= 2.25 / d1) * t + 0.9375;
                    else return n1 * (t -= 2.625 / d1) * t + 0.984375;
                case 'easeInBounce': return 1 - applyEasing(1 - t, 'easeOutBounce');
                case 'easeInOutBounce': return t < 0.5 ? (1 - applyEasing(1 - 2 * t, 'easeOutBounce')) / 2 : (1 + applyEasing(2 * t - 1, 'easeOutBounce')) / 2;
                default: return t;
            }
        }

        function togglePlay() {
            isPlaying = !isPlaying;
            document.getElementById('play-btn').innerHTML = isPlaying ? '&#9208;&#65039;' : '&#9654;&#65039;';
        }

        function stopAnimation() {
            isPlaying = false;
            currentTime = 0;
            document.getElementById('play-btn').innerHTML = '&#9654;&#65039;';
            updateTimeDisplay();
            updateProgress();
        }

        function seek(event) {
            var bar = document.getElementById('progress-bar');
            var rect = bar.getBoundingClientRect();
            var x = event.clientX - rect.left;
            var progress = Math.max(0, Math.min(x / rect.width, 1));
            currentTime = progress * getAnimationEndTime();
            updateTimeDisplay();
            updateProgress();
        }

        function updateTimeDisplay() {
            document.getElementById('time-display').textContent = (currentTime / 1000).toFixed(2) + 's';
        }

        function updateProgress() {
            var endTime = getAnimationEndTime();
            var pct = endTime > 0 ? (currentTime / endTime) * 100 : 0;
            document.getElementById('progress-fill').style.width = pct + '%';
        }
    </script>
</body>
</html>
